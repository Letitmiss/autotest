# 函数式编程

函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。

函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！

Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。

# 高阶函数 

## 变量可以指向函数
以Python内置的求绝对值的函数abs()为例，调用该函数用以下代码：
```
# 变量可以指向函数,
print(abs(-10))  
print(abs)      

# abs是一个内置函数, abs(-10) 是函数调用
# 函数的结果可以复制给变量,没问题, 函数本身也可以赋值给变量 , 
# 如果一个变量指向了一个函数，那么，可否通过该变量来调用这个函数
f = abs;
print(f(-2)) 
# 变量f指向了abs函数,变量可以指向函数
```
## 函数名也是变量

*  函数名其实就是指向函数的变量, 如果给函数名赋值, 函数名变量指向就不会是函数,会报错, 实际过程中,不能这样给内置函数赋值
```
# abs = 10
# abs(-10)
#
#   abs(-10)
# TypeError: 'int' object is not callable
```

## 入参是函数

* 数学中有 f1(z)= f2(x)+f3(y) ,  函数传入两个参数,并传入函数,按照指定的函数运算再求和
```
def f(x, y , f):
    return f(x)+f(y)
    
print(f(-10,20,abs))

```
## 返回值是函数
* 在函数中定义一个函数, 把函数作为返回值返回
```
#如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：
def lazy_sum(*args):
    def cal_sum():
        a = 0
        for arg in args:
            a = a + arg
        return a
    return cal_sum;

#调用lazy_sum 返回的不是结果而是一个函数
f=lazy_sum(*[1,2,3,4,5])
print(lazy_sum(*[1,2,3,4,5]))   #输出 <function lazy_sum.<locals>.cal_sum at 0x0033A468>
# 等调用cal_sums时才返回结果
print(f()) # 15 
````

## 匿名函数
* lambda 表达式
```
squares = list(map(lambda x: x**2, range(10)))
或者，等价于
squares = [x**2 for x in range(10)]

# 匿名函数也是一个变量
f2 = lambda x:x*x
print(f2(5))

# 匿名函数也可以作为返回值
f3=lambda x,y:x*x+y*y
print(f3(3,5))
```

# map/reduce

*  需要了解MapReduce计算模型 , 百度
*  map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到 序列的每个元素，并把结果作为新的Iterator返回。

```
from collections.abc import Iterator
def f(x):
    return x*x
r = map(f,list(range(10)))
print(isinstance(r,Iterator)) # true
print(list(map(f,range(10)))) # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
print(list(map(lambda x:x**2,range(10)))) # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
print(list(map(str,list(range(10))))) # ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

# 首字母大写,转化
def normalize(name):
    a = str(name[:1]).upper()
    b = str(name[1:]).lower()
    return a+b

L1 = ['adam', 'LISA', 'barT']
L2 = list(map(normalize, L1))
print(L2) # ['Adam', 'Lisa', 'Bart']
```
* reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：        
  reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
 
 ```
from functools import reduce
def add(x,y):
    return x + y
print(reduce(add,[1,3,5,7])) # 循环加法运算,不过实际过程中,用sum,不适用这个,只是展示reduce的这种效果

#求积运算
def prod(x,y):
    return x*y
print(reduce(prod,[3,5,7,9]))

 
 ```

## filter

* filter(function, iterable)
用 iterable 中函数 function 返回真的那些元素，构建一个新的迭代器。iterable 可以是一个序列，一个支持迭代的容器，或一个迭代器。如果 function 是 None ，则会假设它是一个身份函数，即 iterable 中所有返回假的元素会被移除。
```
# 筛选出奇数
def is_odd(n):
    return n % 2 == 1
print(list(filter(is_odd , list(range(10)))))
print(list(filter(lambda x: x % 2 == 1, range(10))))

# 把序列的空字符串去掉

def not_empty(s):
    return s and s.strip()

print(list(filter(not_empty,['A', '', 'B', None, 'C', '  '])))  #['A', 'B', 'C'] 

# 去除list列表中假元素
print(list(filter(None,['A', '', 'B', None, 'C', '  '])))  #  ['A', 'B', 'C', '  ']
```







